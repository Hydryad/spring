---Shaders

---
---@return string infoLog
function gl.GetShaderLog() end

---Parameters
---@param shaderParams table
---@return number  shaderID

    ({[ vertex   = "glsl code" ,]
      [ tcs      = "glsl code" ,]
      [ tes      = "glsl code" ,]
      [ geometry = "glsl code" ,]
      [ fragment = "glsl code" ,]
      [ uniform       = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
      [ uniformInt    = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
      [ uniformFloat  = { uniformName = number value, ...} ,] (specify a Lua array as an argument to uniformName to initialize GLSL arrays)
      [ uniformMatrix = { uniformName = number value, ...} ,]
      [ geoInputType = number inType,]
      [ geoOutputType = number outType,]
      [ geoOutputVerts = number maxVerts,]
      [ definitions = "string of shader #defines", ]
    })

 - The "Vertex" or vertex-shader is your GLSL-Code as string, its written in a C-Dialect. This shader is busy deforming the geometry of a unit but it can not create new polygons. Use it for waves, wobbling surfaces etc.
 - The "Geometry" or Geometry-shader can create new vertices and vertice-stripes from points.
 - The "TCS" or Tesselation Control Shader controls how much tessellation a particular patch gets; it also defines the size of a patch, thus allowing it to augment data. It can also filter vertex data taken from the vertex shader. The main purpose of the TCS is to feed the tessellation levels to the Tessellation primitive generator stage, as well as to feed patch data (as its output values) to the Tessellation Evaluation Shader stage.
 - The "TES" or Tesselation Evaluation Shader takes the abstract patch generated by the tessellation primitive generation stage, as well as the actual vertex data for the entire patch, and generates a particular vertex from it. Each TES invocation generates a single vertex. It can also take per-patch data provided by the Tessellation Control Shader.
 - The "Fragment" or Fragment-shader (sometimes called pixel-Shader) is post processing the allready rendered picture (for example drawing stars on the sky)- remember textures are not always 2 dimensional pictures. They can contain information about the depth, or the third value marks areas and the strength at which these are processed.
 - The Uniforms are the values, you send along with the shader-program. To use them in the shader-program declare them like this: `uniform float frame;`

 The engine will automatically fill in an appropriately named uniform for team colour if it is declared;

    uniform vec4 teamColor;
function gl.CreateShader(shaderParams) end

---Parameters
---@param shaderID number
---@return nil
function gl.DeleteShader(shaderID) end

---Parameters
---@param shaderID number
---@return bool linked
function gl.UseShader(shaderID) end

---Parameters
---@param shaderID number
---@param func function
---@param arg1 any (optional)
---@param arg2 any (optional)
---@param argn any (optional)
---@return nil
function gl.ActiveShader(shaderID, func[, arg1[, arg2[, argn]]]) end

---Parameters
---@param shaderID number
---@return table `ActiveUniforms = { { name = "name", type = "type", length = number length, size = number size }, ...}`
function gl.GetActiveUniforms(shaderID) end

---Parameters
---@param shaderID number
---@param name string
---@return number locationID
function gl.GetUniformLocation(shaderID, name) end

---Parameters
---@param locationID number
---@param f1 number
---@param f2 number (optional)
---@param f3 number (optional)
---@param f4 number (optional)
---@return nil
function gl.Uniform(locationID, f1[, f2[, f3[, f4]]]) end

---Parameters
---@param locationID number
---@param int1 number
---@param int2 number (optional)
---@param int3 number (optional)
---@param int4 number (optional)
---@return nil
function gl.UniformInt(locationID, int1[, int2[, int3[, int4]]]) end

---Parameters
---@param locationID number
---@param type number
---@param uniforms table
---@return nil
function gl.UniformArray(locationID, type, uniforms) end

---Parameters
---@param locationID number
---@param m1 ?string|number
---@param m2 number (optional)
---@param mn number (optional)
---@param m16 number (optional)
---@return nil
function gl.UniformMatrix(locationID, m1[, m2[, mn[, m16]]]) end

---Parameters
---@param shaderID number
---@param param number
---@param number number
---@return nil
function gl.SetGeometryShaderParameter(shaderID, param, number) end

---Parameters
---@param param number
---@param number number
---@return nil
function gl.SetTesselationShaderParameter(param, number) end

